# 1. 리뷰 감성분석 MVP 구현 계획
1.1. 목적
- 전통적인 머신러닝 기법을 활용하여 가볍고 빠른 한국어 리뷰 감성분석 시스템 구축
1.2 핵심 원칙
- 경량화, 빠른 추론, 낮은 메모리, 쉬운 업데이트
1.3 기술 스택
- 형태소 분석 : kiwipiepy
- 특징 추출 : TF-IDF
- 분류 모델 : Scikit-learn의 Logistic Regression
- 모델 저장 : joblib
- 메타데이터 저장 -> mlops 기초 수립
- 성능 평가 : scikit-learn metrics

# 2. 시스템 아키텍쳐
```markdown
┌─────────────────────────────────────────────────────┐
│                   Django View                        │
│              (ComparisonViewSet)                     │
└───────────────────┬─────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────┐
│            SentimentProcessor                        │
│         (ai_models/processor.py)                     │
│                                                       │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────┐  │
│  │ Preprocessor │→ │  Vectorizer  │→ │ Predict  │  │
│  │   (Kiwi)     │  │   (TF-IDF)   │  │  (LR)    │  │
│  └──────────────┘  └──────────────┘  └──────────┘  │
└───────────────────┬─────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────┐
│         sentiment_pipeline.joblib                    │
│    (TfidfVectorizer + LogisticRegression)           │
└─────────────────────────────────────────────────────┘

                    ▲
                    │ 학습
                    │
┌─────────────────────────────────────────────────────┐
│     Django Management Command                        │
│       (train_model.py)                               │
│                                                       │
│  1. 데이터 로드 (CSV/JSON/DB)                       │
│  2. 전처리 (Kiwi 토크나이징)                        │
│  3. 학습 (TF-IDF + LR)                              │
│  4. 평가 (정확도, F1-Score)                         │
│  5. 모델 저장 (.joblib)                             │
└─────────────────────────────────────────────────────┘
```

# 3. 디렉토리 구조
```markdown
apps/comparisons/
├── ai_models/
│   ├── __init__.py
│   ├── processor.py                  # 감성분석 추론 프로세서
│   ├── sentiment_pipeline.joblib     # 학습된 모델 (git ignore)
│   └── model_metadata.json           # 모델 메타데이터 (버전, 정확도 등)
│
├── management/
│   └── commands/
│       ├── train_model.py            # 모델 학습 커맨드
│       └── evaluate_model.py         # 모델 평가 커맨드
│
├── fixtures/
│   ├── sentiment_training_data.csv   # 초기 학습용 더미 데이터
│   └── sentiment_test_data.csv       # 테스트용 데이터
│
└── tests/
    └── test_sentiment.py             # 감성분석 테스트
```

### 앱 디렉토리 구성에 대한 추가 설명
**1. 학습과 추론의 분리**

- `Management Commands` : 학습 담당 | 일회성 + 주기적인 작업을 수행하기 위한 인터페이스
- `Processor` : 추론 담당 | 실제 서비스 로직에서 실시간을 호출되는 엔진
-> 학습은 가끔 발생하지만, 추론은 유저가 요청할때마다 발생하므로, Processor를 명령 도구에 묶어두면 API코드에서 호출하기가 매우 부적절하며 재사용성이 떨어짐

**2. 메모리 효율성과 로딩 전략**

- Django의 Command는 실행될 때마다 프로세스가 새로 뜨고 종료됨. 만약 `trian_model.py`안에 추론 로직깢 ㅣ넣어둔다면, API가 호출될 때마다 무거운 모델 파일을 매번 joblib.load()로 읽어와야 한다.
- `Processor`를 별도로 분리하면, Django 서버가 구동될 때, 메모리에 딱 한 번만 모델을 로드(singleton)하고, 모든 유저 요청에 대해서 공유할 수 있다.
    - 자원 절약 : `.joblib`은 용량이 크니까, 유저가 접속할 때마다 새로 읽지 말고, 미리 읽어두자
    - 데이터 공유 : 프로그램 전체에서 동일한 모델 인스턴스를 공유해서 일관된 결과를 얻자.
    - 로딩 시간 단축 : 서버가 시작될 때 딱 한 번만 로드해두면, 이후 요청에는 이미 메모리에 올라와있는 모델을 즉시 사용해서 응답 속도가 비약적으로 빨라진다.
-> 실시간 API응답을 위해 모델을 메모리에 상주시켜야 한다. 전용 프로세서를 두어 모델 로딩을 최적하하고 레이턴시를 최소화하기 위함.

**3. 테스트 및 모듈화**

- `management/commands`에 로직이 들어가면 단위 테스트 작성하기 까다로움. 명령어를 실행하고 결과를 캡쳐하는 방식으로 테스트해야하기 때문
- `Processor.py`로 분리되어 있으면, 단순한 Python 함수/클래스로 취급하여 다양한 입력값(빈 문자열, 특수 문자 등)에 대해 빠르고 정확하게 테스트 코드를 작성할 수 있다.
-> 감성분석을 프레임워크의 도구인 Commands로부터 독립시켜서 코드의 테스트 용이성을 확보하고, 추후 다른 서비스에서도 해당 클래스만 재사용할 수 있도록 모듈화한 것


# TODO
- 캐싱 추가
- `apps/comparisons/tasks.py` 비동기처리(Celery) 추가 고려